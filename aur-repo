#!/bin/bash
# aur-repo - keep your local repo with packages from AUR up to date
# Version : 0.0.2dev
# Author  : Jan-Erik Rediger (badboy_) <badboy at archlinux dot us>
# URL     : https://github.com/badboy/aur-repo
#
#        Based on work by Thorsten Toepper, who initially create aur-repo.
#        Thorsten's version was inspired and partly based on work by
#        Stefan Husmann and Michal Krenek

AURURL="http://aur.archlinux.org/packages"
REBUILD=0
LOCALVER=0
LOCALREL=1
AURVER=0
AURREL=1
AURGET="aurget"
DBEXT=".db.tar.gz"
PKGEXT=".pkg.tar.gz"

BUILDDIR="${BUILDDIR:-/build}"
PACKAGEDIR="${PACKAGEDIR:-/packages}"
REPOCONF="${BUILDDIR}/repo.conf"
DRY_RUN=0

log() {
    echo $@
    [ ${DRY_RUN} -eq 0 ] && echo "[`date +'%Y-%m-%d %H:%M'`]: $@" >> ${BUILDDIR}/${REPONAME}.log
}

die() {
    log $@
    exit 1
}

exp_path() {
    echo "`cd ${1}; pwd`";
}

shell_run() {
    if [ $DRY_RUN -eq 0 ]; then
        $@
    else
        echo "DRYRUN: ${@}"
    fi
}

reporemove() {
    if [ -f "${PACKAGEDIR}/${REPONAME}${DBEXT}" ]; then
        shell_run repo-remove "${PACKAGEDIR}/${REPONAME}${DBEXT}" "${1}"
    fi
}

repoadd() {
    shell_run repo-add "${PACKAGEDIR}/${REPONAME}${DBEXT}" "${1}"
}

download() {
    wget -qO "${BUILDDIR}/.cache/${PACKAGE}.tar.gz" "${AURURL}/${PACKAGE}/${PACKAGE}.tar.gz"
    if [ $? -ne 0 ]; then
        log "Can't download '${PACKAGE}.tar.gz'. Skipping this package..."
        rm -f "${BUILDDIR}/.cache/${PACKAGE}.tar.gz"
        return 1
    fi
    cd ${BUILDDIR}/.cache
    tar -xf ${BUILDDIR}/.cache/${PACKAGE}.tar.gz
    return 0
}

get_pkgver() {
    if [ -f "${1}" ]; then
        grep "^pkgver=" "${1}" | cut -d'=' -f2
    else
        echo 0
    fi
}

get_pkgrel() {
    if [ -f "${1}" ]; then
        grep "^pkgrel=" "${1}" | cut -d'=' -f2
    else
        echo 0
    fi
}

diff_pkg() {
    AURVER=`get_pkgver ${BUILDDIR}/.cache/${PACKAGE}/PKGBUILD`
    AURREL=`get_pkgrel ${BUILDDIR}/.cache/${PACKAGE}/PKGBUILD`
    if [ `find "${PACKAGEDIR}" -type f -name "${PACKAGE}*${PKGEXT}" | wc -l` -ne 0 ]; then
        LOCALVER=`get_pkgver ${BUILDDIR}/${PACKAGE}/PKGBUILD`
        LOCALREL=`get_pkgrel ${BUILDDIR}/${PACKAGE}/PKGBUILD`

        if [ ${REBUILD} -eq 1 ]; then
            rm "${BUILDDIR}/${PACKAGE}/PKGBUILD"
        elif [ -f "${BUILDDIR}/${PACKAGE}/PKGBUILD" ]; then
            VERCMP=`vercmp "${AURVER}" "${LOCALVER}"`
            if [ ${VERCMP} -gt 0 ]; then
                REBUILD=1
            elif [ ${VERCMP} -eq 0 ]; then
                VERCMP=`vercmp "${AURREL}" "${LOCALREL}"`
                if  [ ${VERCMP} -gt 0 ]; then
                    REBUILD=1
                else
                    REBUILD=0
                fi
            fi
        else
            REBUILD=1
        fi
    else
        LOCALVER=nil
        LOCALREL=nil
        REBUILD=1
    fi

    # Put into log
    if [ ${REBUILD} -eq 0 ]; then
        log "${PACKAGE} is up to date."
    else
        shell_run cp -r ${BUILDDIR}/.cache/${PACKAGE} ${BUILDDIR}/
        log "${PACKAGE} will be updated. (${LOCALVER}-${LOCALREL} -> ${AURVER}-${AURREL})"
    fi

    cd ${BUILDDIR}
}

build() {
    if [ "${1}" != "nodiff" ]; then
        diff_pkg
    fi

    if [ ${REBUILD} -eq 1 ]; then
        reporemove ${PACKAGE}
        shell_run find "${PACKAGEDIR}" -type f -name "${PACKAGE}*${PKGEXT}" -delete

        if [ -d "${BUILDDIR}/${PACKAGE}" ]; then
            cd ${BUILDDIR}/${PACKAGE}
            shell_run find  . -type f -iname "${PACKAGE}*${PKGEXT}" -delete
            shell_run makepkg -f
            if [ $? -ne 0 ]; then
                log "(${PACKAGE}) Package build failed...skipping"
                REBUILD=0
            fi
            find . -iname "*${PKGEXT}" -exec cp {} ${PACKAGEDIR}/ \;
        else
            log "(${PACKAGE}) Package not found...skipping"
            REBUILD=0
        fi
    fi

    cd ${PACKAGEDIR}
}

get_data() {
    if [ -f "${BUILDDIR}/${PACKAGE}/pkg/.PKGINFO" ]; then
        # " =" to avoid misuse using the url tag.
        pkgver=`grep "^pkgver =" ${BUILDDIR}/${PACKAGE}/pkg/.PKGINFO | cut -d "=" -f 2|cut -d " " -f 2`
        CARCH=`grep "^arch =" ${BUILDDIR}/${PACKAGE}/pkg/.PKGINFO | cut -d "=" -f 2|cut -d " " -f 2`
        return 0
    else
        return 1
    fi
}

show_help() {
cat << EOF
Usage: $(basename ${0})
$(basename ${0}) [-n] [command] [options]

  -n : Dry run. Show executed commands but don't run them.

Commands:
  update                    Update the whole repository.
  update package            Force update of the specified package
  add package [mode]        Add new package to the list, 'mode' is the same as
                            in the config file and defaults to 'm'.
  addbuild package [mode]   Same as above plus building the package right away.
  info                      Show some info about the repository.
  list                      List all current packages in the repository database.

Config file example:

  REPONAME=my-repo
  GET_FROM_AUR=(
    package1=a
    package2=m
    package3=n
  )

Options:
a ... build always a new package
m ... only build a new package if the PKGBUILD in AUR changed
n ... ignore package (useful if the package at AUR is currently broken)
EOF
}

setup() {
    # Check given path and show help
    if [ ! -f "${REPOCONF}" ]; then
        echo "No config found."
        show_help
        exit 1
    fi

    # Include the configuration
    source ${REPOCONF}
    log "---> using ${REPOCONF}"
    log "---> Repo: ${REPONAME}"

    cd ${BUILDDIR}
    if [ $? -eq 1 ]; then
        die "Can't find build dir: ${BUILDDIR}"
    fi

    if [ ! -d "${BUILDDIR}/.cache" ]; then
        mkdir "${BUILDDIR}/.cache"
    fi

    # Include makepkg.conf for PKGEXT
    source /etc/makepkg.conf
    if [ "${PKGEXT}" = "" ]; then
        PKGEXT=".pkg.tar.gz"
    fi
}

update_one() {
    PACKAGE=${1}
    BUILD_ONE=1
    log "---> Update '${PACKAGE}'"

    NO_DOWNLOAD=1
    if [ ! -d "${BUILDDIR}/${PACKAGE}" ]; then
        NO_DOWNLOAD=0
        if download; then
            shell_run cp -r ${BUILDDIR}/.cache/${PACKAGE} ${BUILDDIR}/
        else
            die "Download failed. Nothig to work on."
        fi
    fi

    if [ ! -d "${BUILDDIR}/${PACKAGE}" ]; then
        die "(${PACKAGE}) Package not found...skipping."
    fi

    REBUILD=1
    build nodiff
    get_data
    if [ $? -eq 0 ]; then
        repoadd ${PACKAGE}-${pkgver}-${CARCH}${PKGEXT}
    fi

    log "---> update finished."
}

update_all() {
    log "---> full update"

    if [ ${#GET_FROM_AUR[@]} -eq 0 ]; then
        die "Error in configuration or no packages specified."
    fi

    # Download package, check option, build it and add it to repository
    for ITEM in "${GET_FROM_AUR[@]}"; do
        PACKAGE=$(echo ${ITEM} | cut -d "=" -f 1)
        PACKAGE_ACTION=$(echo ${ITEM} | cut -d "=" -f 2)
        REBUILD=0

        case ${PACKAGE_ACTION} in
            a)
                download
                if [ $? -ne 0 ]; then
                    continue
                fi
                REBUILD=1
                build
                get_data
                if [ $? -eq 0 ]; then
                    shell_run repoadd ${PACKAGE}-${pkgver}-${CARCH}${PKGEXT}
                    # clean up build dir (in -git packages)
                    if [ -d "${BUILDDIR}/${PACKAGE}/src/*-build" ]; then
                        rm -rf ${BUILDDIR}/${PACKAGE}/src/*-build
                    fi
                fi
                ;;
            m)
                download
                if [ $? -ne 0 ]; then
                    continue
                fi
                build
                if [ ${REBUILD} -eq 1 ]; then
                    get_data
                    if [ $? -eq 0 ]; then
                        rm -rf ${BUILDDIR}/${PACKAGE}/{src,pkg}
                        shell_run repoadd ${PACKAGE}-${pkgver}-${CARCH}${PKGEXT}
                    fi
                fi
                ;;
            *)
                log "${PACKAGE} will be ignored."
                ;;
        esac
    done
    log "---> full update finished."
}

add_package() {
    if [ -z "${1}" ]; then
        die "Please give a package name and optional a new mode."
    fi
    NEW_PACKAGE=${1}

    if [ -n "${2}" ]; then
        if [ ${2} != "m" ] && [ ${2} != "n" ] && [ ${2} != "a" ]; then
            die "Please choose a correct mode: a=always, m=modified, n=never"
        fi
        NEW_MODE=${2}
    else
        NEW_MODE=m
    fi

    for ITEM in "${GET_FROM_AUR[@]}"; do
        PACKAGE=$(echo ${ITEM} | cut -d "=" -f 1)
        PACKAGE_ACTION=$(echo ${ITEM} | cut -d "=" -f 2)

        if [ "${PACKAGE}" = "${NEW_PACKAGE}" ]; then
            die "The specified package is already in your list. Please change mode manually."
        fi
    done

    (
        echo "REPONAME=${REPONAME}"
        echo "GET_FROM_AUR=("
        for ITEM in "${GET_FROM_AUR[@]}"; do
            PACKAGE=$(echo ${ITEM} | cut -d "=" -f 1)
            PACKAGE_ACTION=$(echo ${ITEM} | cut -d "=" -f 2)

            if [ "${PACKAGE}" = "${NEW_PACKAGE}" ]; then
                die "The specified package is already in your list. Please change mode manually."
            fi
            echo "    ${ITEM}"
        done
        echo "    ${NEW_PACKAGE}=${NEW_MODE}"
        echo ")"
    ) > "${REPOCONF}"
    log "---> Added ${NEW_PACKAGE} to ${REPOCONF}"

}

if [ "${1}" = "-n" ]; then
    DRY_RUN=1
    log "---> DRYRUN!"
    shift
fi

list_packages() {
    tar -atf "${PACKAGEDIR}/${REPONAME}${DBEXT}" | sed 's#/.\+\?##' | uniq
}


setup

case "${1}" in
    add)
        shift
        add_package ${@}
        ;;
    addbuild)
        shift
        add_package ${@}
        update_one "${1}"
        ;;
    update|build)
        if [ -z "${2}" ]; then
            update_all
        else
            update_one "${2}"
        fi
        ;;
    list)
        list_packages
        ;;
    info)
        echo "Config          : ${REPOCONF}"
        echo "Logfile         : ${BUILDDIR}/${REPONAME}.log"
        echo "Repository      : ${REPONAME}"
        echo "Builddir        : ${BUILDDIR}"
        echo "Packagedir      : ${PACKAGEDIR}"
        echo "No. of packages : ${#GET_FROM_AUR[@]}"
        ;;
    -h|help)
        show_help
        ;;
    *)
        show_help
        ;;
esac

exit 0
